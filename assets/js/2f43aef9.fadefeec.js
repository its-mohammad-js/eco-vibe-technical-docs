"use strict";(self.webpackChunkeco_vibe_document=self.webpackChunkeco_vibe_document||[]).push([[3953],{7795:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Custom Hooks/Custom Hooks","title":"Custom Hooks","description":"Overview","source":"@site/docs/Custom Hooks/Custom Hooks.md","sourceDirName":"Custom Hooks","slug":"/Custom Hooks/","permalink":"/eco-vibe-technical-docs/docs/Custom Hooks/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Custom Hooks/Custom Hooks.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Other Concepts","permalink":"/eco-vibe-technical-docs/docs/category/other-concepts"},"next":{"title":"File Structure rules","permalink":"/eco-vibe-technical-docs/docs/Custom Hooks/File Structure rules"}}');var i=t(4848),o=t(8453);const r={sidebar_position:1},a=void 0,c={},l=[{value:"Overview",id:"overview",level:3},{value:"useDisableScroll",id:"usedisablescroll",level:3},{value:"useGetOptions",id:"usegetoptions",level:3},{value:"useMediaQuery",id:"usemediaquery",level:3},{value:"useOutsideCall",id:"useoutsidecall",level:3},{value:"useRemoveSlide",id:"useremoveslide",level:3},{value:"useResizeListener",id:"useresizelistener",level:3},{value:"useTouchScroll",id:"usetouchscroll",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"One of the easiest and most efficient ways to globalize repetitive logic is by creating custom hooks. Due to the relative complexity of the project, varying device behaviors, and diverse requirements, the number of custom hooks developed for this project is somewhat higher than usual. These hooks allow us to manage specific, repetitive logic in a centralized way and share it effectively across different parts of the application, eliminating the need for duplicated or complex code. As a result, using custom hooks significantly improves code quality, ease of maintenance, and provides greater flexibility. The custom hooks that have not been explained so far will now be reviewed."}),"\n",(0,i.jsx)(n.h3,{id:"usedisablescroll",children:"useDisableScroll"}),"\n",(0,i.jsxs)(n.p,{children:["The custom hook in question, as its name suggests, is responsible for disabling the ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"window"})})," scroll at specific moments. This hook is purposefully designed to halt scrolling in certain scenarios, ensuring that only specific interactions are active for the user. This feature is especially useful when there is a need for precise control over the page behavior and its interactions."]}),"\n",(0,i.jsx)(n.p,{children:"Two main conditions cause the scroll to be disabled:"}),"\n",(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["The maximum ",(0,i.jsx)(n.strong,{children:"screen width"})," passed to the component."]}),(0,i.jsxs)("li",{children:["A ",(0,i.jsx)(n.strong,{children:"custom condition"})," passed to the component."]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",metastring:'title="useDisableScroll"',children:'const useDisableScroll = (minWidth = 480, condition) => {\n  // detect size screen\n  const screenSize = useMediaQuery({ maxWidth: minWidth });\n\n  // hidden window scroll-bar on mount\n  useEffect(() => {\n    const checkScreen = Number.isInteger(minWidth) ? screenSize : minWidth;\n\n    document.body.style.overflow =\n      !checkScreen || condition ? "auto" : "hidden";\n\n    return () => {\n      document.body.style.overflow = "auto";\n    };\n  }, [condition, screenSize]);\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"usegetoptions",children:"useGetOptions"}),"\n",(0,i.jsxs)(n.p,{children:["A key part of the application's information, which includes all the products associated with it, are the supported options stored in the database. To globalize the server requests for the supported options, ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/common/hooks/useGetOptions.jsx",children:"this custom hook"})})," is implemented. The main logic of the hook is that it stores the received options in the browser's local memory, and if no previous data is found, it sends a request to the server."]}),"\n",(0,i.jsx)(n.h3,{id:"usemediaquery",children:"useMediaQuery"}),"\n",(0,i.jsx)(n.p,{children:"Determining the maximum expected screen width is often crucial for logical operations and the way components are rendered."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",metastring:'title="useMediaQuery"',children:'const useMediaQuery = ({ maxWidth }) => {\n  // width check state\n  const [widthCheck, setWidthCheck] = useState(null);\n  // check max width on app mount & resize events\n  useEffect(() => {\n    setWidthCheck(window.innerWidth <= maxWidth);\n\n    function handleResize(e) {\n      setWidthCheck(window.innerWidth <= maxWidth);\n    }\n\n    window.addEventListener("resize", handleResize);\n\n    return () => {\n      window.removeEventListener("resize", handleResize);\n    };\n  }, [maxWidth, window.innerWidth, window.innerHeight]);\n  // return results\n  return widthCheck || window.innerWidth <= maxWidth;\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"useoutsidecall",children:"useOutsideCall"}),"\n",(0,i.jsxs)(n.p,{children:["The functionality, which is an important and commonly used feature in most React applications, is employed to handle click events outside a specified area and execute a callback. The only additional part in this logic is ",(0,i.jsx)(n.code,{children:"defaultState"}),", which, if its value is truthy, prevents the callback from being executed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",metastring:'title="useOutSideClick"',children:'const useOutSideClick = (elRef, callBack, defaultState) => {\n  useEffect(() => {\n    if (defaultState) {\n      return;\n    }\n\n    const handleOutside = (e) => {\n      if (elRef.current && !elRef.current.contains(e.target)) {\n        callBack();\n      }\n    };\n\n    document.addEventListener("click", handleOutside);\n\n    return () => {\n      removeEventListener("click", handleOutside);\n    };\n  }, [elRef, defaultState]);\n\n  return elRef;\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"useremoveslide",children:"useRemoveSlide"}),"\n",(0,i.jsxs)(n.p,{children:["A large number of components in the app interact with stories, which makes the two main actions\u2014removing a story and deleting a slide from highlights\u2014become a ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/common/hooks/useRemoveSlide.jsx",children:"central function"})}),". This hook provides two main functions, ",(0,i.jsx)(n.code,{children:"onRemoveHighlight"})," and ",(0,i.jsx)(n.code,{children:"onDeleteSlide"}),", as outputs, handling the entire process for both operations."]}),"\n",(0,i.jsx)(n.h3,{id:"useresizelistener",children:"useResizeListener"}),"\n",(0,i.jsxs)(n.p,{children:["Web applications, due to the varying execution environments, may exhibit different behaviors at different times. One such example is the misalignment of component heights with the browser or various app states. This occurs, for instance, when a user interacts with an on-screen keyboard ",(0,i.jsx)(n.strong,{children:"(on mobile devices)"})," or when the bottom bar in Chrome is visible. In many cases, these unpredictable behaviors necessitate the configuration of the app. Despite the visual similarities with ",(0,i.jsx)(n.code,{children:"useMediaQuery"}),", this hook produces a different output: it returns the main height of the area currently visible to the user."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",metastring:'title="useResizeListener"',children:'useResizeListener() {\n  const [appHeight, setHeight] = useState(null);\n\n  useEffect(() => {\n    const getHeight = () => setHeight(window.visualViewport.height);\n\n    window.addEventListener("resize", getHeight);\n    getHeight();\n\n    return () => {\n      window.removeEventListener("resize", getHeight);\n    };\n  }, []);\n\n  return { appHeight };\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"usetouchscroll",children:"useTouchScroll"}),"\n",(0,i.jsx)(n.p,{children:"Horizontal touch scrolling is almost unavailable in most browsers for larger screen sizes. This custom hook enables this user interaction with containers on larger screen sizes. The architecture and overall structure of this hook are as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",metastring:'title="useHorizontalTouchScroll"',children:'useHorizontalTouchScroll(elClass, renderTime, elRef) {\n  const [isDown, setIsDown] = useState(false);\n  const [startX, setStartX] = useState(false);\n  const [scrollLeft, setScrollLeft] = useState(false);\n  const [container, setContainer] = useState(null);\n\n  // set container\n  useEffect(() => {\n    // note : when a ref attribute is not applicable, we can reference an element by its class name.\n    const containerRef = document.querySelector(elClass);\n\n    setContainer(elRef?.current ? elRef?.current : containerRef);\n  }, [elClass, renderTime, elRef]);\n\n  // set event listener\'s to container\n  useEffect(() => {\n    if (!container) {\n      return;\n    }\n\n    // on mouse down event\n    const setWalk = (e) => {\n      setIsDown(true);\n      container.classList.add("active");\n      setStartX(e.pageX - container.offsetLeft);\n      setScrollLeft(container.scrollLeft);\n    };\n    container.addEventListener("mousedown", setWalk);\n    // on mouse leave/up event\n    const removeWalk = () => {\n      setIsDown(false);\n      container.classList.remove("active");\n    };\n    container.addEventListener("mouseleave", removeWalk);\n    container.addEventListener("mouseup", removeWalk);\n    // scroll event (on mouse move)\n    const walkScroll = (e) => {\n      if (!isDown || ![...container.classList].includes("active")) return;\n      else {\n        e.preventDefault();\n        const x = e.pageX - container.offsetLeft;\n        const walk = (x - startX) * 1; //scroll-fast\n        container.scrollLeft = scrollLeft - walk;\n      }\n    };\n    container.addEventListener("mousemove", walkScroll);\n    // remove all events on component unmount\n    return () => {\n      container.removeEventListener("mousedown", setWalk);\n      container.removeEventListener("mouseleave", removeWalk);\n      container.removeEventListener("mouseup", removeWalk);\n      container.removeEventListener("mousemove", walkScroll);\n    };\n  }, [container, isDown, startX, scrollLeft]);\n\n  return container;\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);