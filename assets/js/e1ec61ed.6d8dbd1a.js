"use strict";(self.webpackChunkeco_vibe_document=self.webpackChunkeco_vibe_document||[]).push([[8849],{3368:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Chat Rooms/Rooms Context","title":"Rooms Context","description":"Overview","source":"@site/docs/Chat Rooms/Rooms Context.md","sourceDirName":"Chat Rooms","slug":"/Chat Rooms/Rooms Context","permalink":"/eco-vibe-technical-docs/docs/Chat Rooms/Rooms Context","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Chat Rooms/Rooms Context.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chat Rooms","permalink":"/eco-vibe-technical-docs/docs/category/chat-rooms"},"next":{"title":"Main Comps","permalink":"/eco-vibe-technical-docs/docs/Chat Rooms/Main Comps"}}');var n=o(4848),a=o(8453);const r={sidebar_position:1},i=void 0,c={},d=[{value:"Overview",id:"overview",level:3},{value:"Rooms Context",id:"rooms-context",level:3},{value:"UseChatRooms",id:"usechatrooms",level:3},{value:"Get Chat Rooms",id:"get-chat-rooms",level:4},{value:"Update Last Seen Of User",id:"update-last-seen-of-user",level:4},{value:"Remove Expired Rooms",id:"remove-expired-rooms",level:3}];function m(e){const t={a:"a",code:"code",em:"em",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h3,{id:"overview",children:"Overview"}),"\n",(0,n.jsxs)(t.p,{children:["Despite all the communication channels that have been provided for sellers and customers so far, nothing beats ",(0,n.jsx)(t.strong,{children:"real-time"})," interaction and chatting. This feature enables direct, real-time chat between sellers and customers, allowing both parties to communicate privately and securely with one another."]}),"\n",(0,n.jsx)(t.p,{children:"This space is designed with a visually appealing and simple interface to optimize the user experience for both types of users (sellers and customers). Through this feature, users can share content and feedback, ask questions, and receive quick responses. This real-time interaction allows sellers to easily address customer issues or requests and maintain direct, effective communication with them."}),"\n",(0,n.jsx)(t.h3,{id:"rooms-context",children:"Rooms Context"}),"\n",(0,n.jsxs)(t.p,{children:["Overall, all information related to user chat rooms is globally accessible through a React ",(0,n.jsx)(t.strong,{children:"context"}),", making it easier to access all the details of the chat rooms. This approach simplifies state management, reduces complexity, and makes data management much easier. By using this method, it ensures that the flow of information within the chat rooms is seamless and that any updates or changes to the chat data are efficiently handled across the application. That's why the main ",(0,n.jsx)(t.em,{children:"chat page"})," is rendered within a ",(0,n.jsx)(t.em,{children:"context"})," that is responsible for storing and managing the core data of the ",(0,n.jsx)(t.em,{children:"chat rooms"}),". ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/RoomsContext.jsx",children:"This context"})})," ensures that the relevant information is easily accessible and synchronized across the app, allowing for smooth interactions and state management within the chat system."]}),"\n",(0,n.jsx)(t.h3,{id:"usechatrooms",children:"UseChatRooms"}),"\n",(0,n.jsxs)(t.p,{children:["The task of receiving and customizing the data related to chat rooms is handled by the ",(0,n.jsx)(t.strong,{children:"useChatRooms"})," custom hook. This hook separates the server-side requests from the main component, keeping the architecture and structure of the application clean and well-organized. By isolating the data-fetching logic, it ensures that the main components remain simple and focused on their core responsibilities."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"In general, the body of this hook is divided into three main parts:"})}),"\n",(0,n.jsx)(t.h4,{id:"get-chat-rooms",children:"Get Chat Rooms"}),"\n",(0,n.jsx)(t.p,{children:"Using this hook, the client\u2019s connection to the server is checked, and the user\u2019s authentication status is verified. After both processes are completed, a request is sent to fetch the chat room data. Due to the use of a real-time database, the gap between the loading completion and receiving the room data is so minimal that there is no need for a separate loading indicator."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:'title="Get Rooms on app mount"',children:'// get all chat rooms on app mount\nuseEffect(() => {\n  if (auth_status === 200) {\n    // declare data base\n    goOnline(db);\n    // ref to connection path\n    const connectedRef = ref(db, ".info/connected");\n    // update connection state & get rooms\n    onValue(connectedRef, (snap) => {\n      if (snap.val() === true && !loading) {\n        // get rooms\n        getRooms();\n      } else {\n        // set loading\n        setRooms({\n          rooms: [],\n          status: "loading...",\n        });\n      }\n    });\n  } else if (auth_status === 401) {\n    // for un-authorized users\n    toast("Create an account to join the chat!");\n    navigate("/EcoVibe/Customers/sign-up");\n  }\n  // disconnect from data base on component on mount\n  return () => {\n    goOffline(db);\n    setRooms({ rooms: [], status: null });\n  };\n}, [userId]);\n'})}),"\n",(0,n.jsx)(t.p,{children:"After that, the function sends a request to fetch the chat room data, retrieves all the chat rooms related to the user, and customizes their data according to the program's requirements."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:'title="get rooms function"',children:'// get chat rooms data\nfunction getRooms() {\n  // ref to related room to current user\n  const roomsRef = query(\n    ref(db, "rooms"),\n    orderByChild(`${userId}/userId`),\n    equalTo(userId)\n  );\n\n  onValue(roomsRef, (snapshot) => {\n    // return 404 state if there wasn\'t any room\n    if (!snapshot.exists()) {\n      setRooms({\n        rooms: [],\n        status: "No Conversations Yet...",\n      });\n      return;\n    }\n    // turn all room object to a list\n    const allRooms = Object.entries(snapshot.val()).map(([k, val]) => ({\n      ...val,\n      roomId: k,\n    }));\n\n    const filteredRooms = allRooms\n      // filter rooms only visible for current user\n      .filter(({ members }) => members.includes(userId))\n      // update each room data & customize it\n      .map((room) => {\n        // declare receiver id\n        const receiverId =\n          room?.members?.find((id) => id !== userId) ||\n          Object.keys(room).find(\n            (key) => ![userId, "roomId", "messageList", "members"].includes(key)\n          );\n        // declare owner last seen\n        const ownerLastSeen = room[userId]?.last_seen;\n        // return customized room object if there was any last seen before (it was used before)\n        if (ownerLastSeen || room?.messageList?.length > 0)\n          return {\n            roomId: room.roomId,\n            messageList: room.messageList || null,\n            members: room.members,\n            // separate owner data from receiver data\n            owner: room[userId],\n            receiver: {\n              ...room[receiverId],\n              receiverId,\n            },\n          };\n      });\n    // update rooms state\n    setRooms({\n      rooms: filteredRooms.filter((room) => room),\n      status: filteredRooms.length ? null : "No Conversations Yet...",\n    });\n  });\n}\n'})}),"\n",(0,n.jsx)(t.h4,{id:"update-last-seen-of-user",children:"Update Last Seen Of User"}),"\n",(0,n.jsx)(t.p,{children:"This effect is specifically designed for situations where the browser or client device unexpectedly closes the selected room, ensuring that the user's last visit in that room is updated correctly."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:'title="update last seen"',children:"// set last seen on disconnect\nuseEffect(() => {\n  if (selectedRoom && userId) {\n    onDisconnect(\n      ref(db, `rooms/${selectedRoom.roomId}/${userId}/last_seen`)\n    ).set({\n      date: serverTimestamp(),\n      offline: true,\n    });\n  }\n}, [selectedRoom, userId]);\n"})}),"\n",(0,n.jsx)(t.h3,{id:"remove-expired-rooms",children:"Remove Expired Rooms"}),"\n",(0,n.jsxs)(t.p,{children:["Chat rooms that have been inactive for both parties for seven days are considered expired and are deleted from the database. This process is carried out by the GitHub Action called ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/.github/workflows/RemoveExpiredChatRooms.yml",children:"remove expired chat rooms"})}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>i});var s=o(6540);const n={},a=s.createContext(n);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);