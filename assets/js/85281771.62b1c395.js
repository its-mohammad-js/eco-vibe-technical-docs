"use strict";(self.webpackChunkeco_vibe_document=self.webpackChunkeco_vibe_document||[]).push([[9828],{6498:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"state management/Products & Filters","title":"Products & Filters","description":"Get products data","source":"@site/docs/state management/Products & Filters.md","sourceDirName":"state management","slug":"/state management/Products & Filters","permalink":"/eco-vibe-technical-docs/docs/state management/Products & Filters","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/state management/Products & Filters.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"User Data","permalink":"/eco-vibe-technical-docs/docs/state management/User Data"},"next":{"title":"Customer experience","permalink":"/eco-vibe-technical-docs/docs/category/customer-experience"}}');var n=s(4848),o=s(8453);const a={sidebar_position:3},i=void 0,c={},d=[{value:"Get products data",id:"get-products-data",level:3},{value:"Filter &amp; sort state",id:"filter--sort-state",level:3}];function l(e){const t={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h3,{id:"get-products-data",children:"Get products data"}),"\n",(0,n.jsxs)(t.p,{children:["The process of fetching and filtering product data is handled by a single ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/reducers/products/productsSlice.js",children:"Action"})}),", and most parts of the app use this state. Due to limitations in using database queries on the Firebase server, the product filtering process is done on the ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/common/utils/filterPorducts.js",children:"client-side"})})," device. Although this might not be the ideal approach, it still works effectively and provides good performance."]}),"\n",(0,n.jsx)(t.h3,{id:"filter--sort-state",children:"Filter & sort state"}),"\n",(0,n.jsxs)(t.p,{children:["As previously mentioned, Redux is used for filtering and sorting data on the explore-products page. The main reason for this is that it is closely integrated with the action that fetches and filters products. Naturally, this approach was easier and more accessible, and it also reduced complexity on the ",(0,n.jsx)(t.strong,{children:"explore-products"})," page. The slice related to the data and filter state is an object containing properties for filtering and sorting. These properties are updated statically, and with every update, an optimized request is sent to the server."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-jsx",metastring:'title="get products on filter changes"',children:"function fetchProducts() {\n  dispatch(getFilteredProducts({ filtersData }));\n}\n\nconst debouncedFetchProducts = useCallback(\n  debounce(() => fetchProducts(), 800),\n  [fetchProducts]\n);\n\n// get filtered products on each filter change\nuseEffect(() => {\n  fetchProducts();\n  // debouncedFetchProducts(filters);\n  return () => debouncedFetchProducts.cancel();\n}, [filters]);\n"})})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>i});var r=s(6540);const n={},o=r.createContext(n);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);