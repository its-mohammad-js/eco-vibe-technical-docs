"use strict";(self.webpackChunkeco_vibe_document=self.webpackChunkeco_vibe_document||[]).push([[2861],{4035:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"Chat Rooms/Main Comps","title":"Main Comps","description":"Chat List","source":"@site/docs/Chat Rooms/Main Comps.md","sourceDirName":"Chat Rooms","slug":"/Chat Rooms/Main Comps","permalink":"/eco-vibe-technical-docs/docs/Chat Rooms/Main Comps","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Chat Rooms/Main Comps.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Rooms Context","permalink":"/eco-vibe-technical-docs/docs/Chat Rooms/Rooms Context"},"next":{"title":"Stories Modal Logic","permalink":"/eco-vibe-technical-docs/docs/Chat Rooms/Stories Modal Logic"}}');var a=s(4848),o=s(8453);const r={sidebar_position:2},i=void 0,c={},l=[{value:"Chat List",id:"chat-list",level:3},{value:"Delete Chat Rooms Rule",id:"delete-chat-rooms-rule",level:4},{value:"Contacts &amp; Create New Chat Room",id:"contacts--create-new-chat-room",level:4},{value:"Search Contacts &amp; Messages in Chat List",id:"search-contacts--messages-in-chat-list",level:4},{value:"Room Layout",id:"room-layout",level:3},{value:"Draggable Element",id:"draggable-element",level:4},{value:"Selected Message Usage &amp; Scrolling",id:"selected-message-usage--scrolling",level:4},{value:"Navbar Search Messages",id:"navbar-search-messages",level:4},{value:"Messages Layout",id:"messages-layout",level:4},{value:"Messages Types",id:"messages-types",level:5},{value:"Send / Edit &amp; Reply To Message",id:"send--edit--reply-to-message",level:4},{value:"Last Seen Logic",id:"last-seen-logic",level:3},{value:"User Info Tab",id:"user-info-tab",level:3}];function h(e){const t={a:"a",code:"code",h3:"h3",h4:"h4",h5:"h5",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h3,{id:"chat-list",children:"Chat List"}),"\n",(0,a.jsxs)(t.p,{children:["The first section of the chat page that the user interacts with is the ",(0,a.jsx)(t.strong,{children:"chat list"}),". It is developed in a modular and simple way, and in terms of appearance, it displays all the available rooms for the user while maintaining details and using a context menu. The details and features of this component will be addressed section by section below."]}),"\n",(0,a.jsx)(t.h4,{id:"delete-chat-rooms-rule",children:"Delete Chat Rooms Rule"}),"\n",(0,a.jsxs)(t.p,{children:["The chat room menu context has its most important feature in the ability to delete chat rooms. Here, this action is being examined. In the object of each room, there is a property called ",(0,a.jsx)(t.strong,{children:"members"}),", which simply and directly determines which users the chat room is visible to. When a one-sided chat room is deleted, the first change is that this array becomes a list with only one element."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="members list of room object"',children:'{\n members: ["userId"],\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the second stage, if the last remaining user in the chat room also deletes the room, it will be completely removed from the database and no longer accessible. However, in the first case, the deletion is ",(0,a.jsx)(t.strong,{children:"one-sided"})," for users, meaning the other user (the counterpart) still has access to the room and the ",(0,a.jsx)(t.strong,{children:"previous chats"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note"}),": It is worth mentioning that after a one-sided deletion, if either of the users sends a new message, causing the chat room to become visible to both parties again, the previous chats that were deleted by the first user will no longer be accessible to them."]}),"\n",(0,a.jsx)(t.h4,{id:"contacts--create-new-chat-room",children:"Contacts & Create New Chat Room"}),"\n",(0,a.jsxs)(t.p,{children:["For both types of users (customers and sellers), the contact list is available. In the first step, all sellers are accessible to message customers. In the second step, sellers can access their customers and create new chat rooms. To create a new chat room in any other part of the application, ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/common/hooks/useCreateChatRoom.jsx",children:"useCreateChatRoom"})})," is used, which is a custom hook that makes the functionality of creating a new chat room accessible across the entire application. The main structure of this hook is that it first checks whether a chat room between the user and the recipient exists. If it doesn't exist, a new chat room is created. Ultimately, in both cases, a ",(0,a.jsx)(t.strong,{children:"callback"})," is executed, which has a different behavior depending on the context in which the hook is called."]}),"\n",(0,a.jsx)(t.h4,{id:"search-contacts--messages-in-chat-list",children:"Search Contacts & Messages in Chat List"}),"\n",(0,a.jsxs)(t.p,{children:["In the chat list, there is a search feature for both contacts and messages, which makes it easier for users to access all chat rooms. This feature is implemented in the ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/Chat%20List/ChatList.jsx",children:"chatList"})})," component and, despite its simplicity, works seamlessly alongside the core functionality of the component, which is to display all chat rooms. Due to the real-time nature of chat updates, this feature also operates in real-time, providing the best possible user experience for a web-based chat platform."]}),"\n",(0,a.jsx)(t.h3,{id:"room-layout",children:"Room Layout"}),"\n",(0,a.jsxs)(t.p,{children:["The core aspect of chat rooms is the layout and how the different components of the chat room are arranged together, which is configured and managed by the ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/Chat%20Room/RoomLayout/RoomLayout.jsx",children:"RoomLayout"})})," component. Each chat room is rendered with a specific layout and related features within this component. This structure ensures that the different elements of the chat room are organized and positioned efficiently, providing a smooth and well-organized chat experience for users."]}),"\n",(0,a.jsx)(t.p,{children:"The overall structure of RoomLayout is designed to position the different components of the chat room together. In this component, all features and settings related to the chat room are executed and rendered. Additionally, the main room size is automatically adjusted when the screen size changes, ensuring that the chat room is always fully accessible and optimized for the user."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="room Layout"',children:'<div\n  style={{\n    height: appHeight,\n  }}\n  className={`${\n    selectedRoom ? "col-span-9 col-start-4 flex" : "hidden"\n  } lg:! flex flex-col lg:w-3/4 !w-full h-full bg-slate-200 items-center justify-center relative`}\n>\n  {/* user info nav */}\n  <div ref={navRef} className="w-full">\n    <Navbar {...{ deleteRoom, setShowAlert }} />\n  </div>\n  {/* messages list */}\n  <MessageList />\n  {/* send message input */}\n  <MessageInput />\n  {/* Draggable element to return to the chat list.  */}\n  {/* This element is only visible on mobile devices and when the virtual keyboard is active. */}\n  <DraggableEl />\n</div>\n'})}),"\n",(0,a.jsx)(t.h4,{id:"draggable-element",children:"Draggable Element"}),"\n",(0,a.jsxs)(t.p,{children:["The idea of creating a ",(0,a.jsx)(t.strong,{children:"draggable element"})," actually stemmed from an ",(0,a.jsx)(t.strong,{children:"unavoidable browser behavior"}),". In most browsers on mobile devices, when the user's keyboard appears, the keyboard is treated as part of the main screen. While the page height adjusts in this situation, a scrollable empty space remains right under the keyboard. This empty space can disrupt the user experience, especially when interacting with elements on the page, which led to the need for creating a draggable element to improve the management of the page's space."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Example Gif",src:s(1341).A+"",width:"376",height:"754"})}),"\n",(0,a.jsxs)(t.p,{children:["As you can observe, the empty space that appears beneath the keyboard has been turned into a sliding element. Now, the user can scroll past it, which allows them to move out of the current chat screen if they ",(0,a.jsx)(t.strong,{children:"scroll too far"}),". User interaction and page scrolling are handled through touch event controls, managed by the custom hook below. It has been developed in a way that provides the best possible user experience without adding unnecessary complexity to the code."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="useTouchHandlers custom hook"',children:'export function useTouchHandlers(selectedRoom, setSelectedRoom, setEl, navRef) {\n  useEffect(() => {\n    // handle touch actions\n    const handleTouch = (e, type) => {\n      // declare touch event\n      const touch = type === "move" ? e.touches[0] : e.changedTouches[0];\n      // declare delta y\n      const deltaY = touch.screenY - touch.pageY;\n      // adjust rotate & opacity of element on touch moves (scrolls)\n      if (type === "move" && deltaY < 87) {\n        const opacity = (touch.pageY - touch.screenY) / 50 + 1.5;\n        const rotate = Math.min(Math.max(opacity * 85, 0), 180);\n        // update element style\n        setEl({\n          opacity: opacity / 3,\n          rotate,\n        });\n      }\n      // finally decide on touch (scroll) end\n      if (type === "end") {\n        // close the chat room if user scrolls down completely\n        if (deltaY < -20) {\n          setSelectedRoom(null);\n        }\n        // scroll up if user hasn\'t enough scroll\n        else if (deltaY < 87) {\n          navRef.current.scrollIntoView({ block: "start", behavior: "smooth" });\n          setEl({ rotate: 0, opacity: 0 });\n        }\n      }\n    };\n    // declare & add event listeners\n    const onTouchMove = (e) => handleTouch(e, "move");\n    const onTouchEnd = (e) => handleTouch(e, "end");\n\n    window.addEventListener("touchmove", onTouchMove);\n    window.addEventListener("touchend", onTouchEnd);\n    // remove events on un-mount\n    return () => {\n      window.removeEventListener("touchmove", onTouchMove);\n      window.removeEventListener("touchend", onTouchEnd);\n    };\n  }, [selectedRoom, setSelectedRoom, setEl, navRef]);\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"selected-message-usage--scrolling",children:"Selected Message Usage & Scrolling"}),"\n",(0,a.jsx)(t.p,{children:"Throughout various stages of user interaction with the application, the user may want to target a specific message, reply to it, or edit it. The central state that tracks the targeted message is crucial for managing and synchronizing all chat components, ensuring a seamless and consistent user experience."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="selected message state"',children:"const [selectedMessage, setSelectedMessage] = useState(null); // selected message state\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="access to selected message"',children:"const { selectedMessage } = useRoomsData();\n"})}),"\n",(0,a.jsx)(t.p,{children:"When the user selects a message through the search functionality, the messages list must automatically scroll to that specific message."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="scroll to selected message"',children:'// scroll to selected message\nuseEffect(() => {\n  if (selectedMessage) {\n    const selectedMessageEl = document.getElementById(\n      `${selectedMessage.uiid}`\n    );\n\n    selectedMessageEl.scrollIntoView({\n      behavior: "smooth",\n      block: "end",\n    });\n  }\n}, [selectedMessage]);\n'})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note:"})," The reason for referencing the selected message through the DOM is that it wasn't possible to define a local reference for it and pass it down to all components."]}),"\n",(0,a.jsx)(t.h4,{id:"navbar-search-messages",children:"Navbar Search Messages"}),"\n",(0,a.jsxs)(t.p,{children:["One of the most important features of the chat room is the ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/Chat%20Room/RoomLayout/Navbar/Navbar.jsx",children:"notification bar"})}),", which displays various information, including user details and their last visit. The first feature of the notification bar is the in-chat search, which allows the user to search in real-time through all the messages exchanged in the chat room. When a user performs a search within the messages, the layout of the chat room adjusts, allowing the user to see their search results and scroll through the messages accordingly."]}),"\n",(0,a.jsx)(t.h4,{id:"messages-layout",children:"Messages Layout"}),"\n",(0,a.jsxs)(t.p,{children:["Given the diversity of message types, a ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/Chat%20Room/Messages%20List/MessageLayout.jsx",children:"general layout"})})," for the messages is designed, determining the placement, timestamp, and overall styling of the messages according to the sender. This layout plays a crucial role in constructing the message list. Moreover, the message context menu, offering options to reply, edit, or delete messages, is seamlessly incorporated into this component."]}),"\n",(0,a.jsx)(t.h5,{id:"messages-types",children:"Messages Types"}),"\n",(0,a.jsxs)(t.p,{children:["Overall, the primary types of messages that can be sent and rendered include text messages, order or purchase messages, product-related messages, and location-based messages. The UI switches between different message types based on the ",(0,a.jsx)("code",{children:"type"})," property."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="message type switcher"',children:'{\n  message.type === "text" ? (\n    <p className="text-start w-full break-words max-w-96">{message.content}</p>\n  ) : message.type === "order" ? (\n    <OrderTypeMessage message={message} />\n  ) : message.type === "location" ? (\n    <LocationTypeMessage message={message} />\n  ) : (\n    <ProductTypeMessage message={message} />\n  );\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"send--edit--reply-to-message",children:"Send / Edit & Reply To Message"}),"\n",(0,a.jsxs)(t.p,{children:["Users can send and edit messages in real-time through the ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/its-mohammad-js/EcoVibe/blob/main/src/pages/Main%20Pages/Chat/components/Chat%20Room/RoomLayout/MessageInput/MessageInput.jsx",children:"messageInput.jsx"})})," component, which provides easy access to these actions. In addition, users have the ability to reply to both their own and their recipient's messages, and can send various types of messages."]}),"\n",(0,a.jsx)(t.h3,{id:"last-seen-logic",children:"Last Seen Logic"}),"\n",(0,a.jsx)(t.p,{children:"To enhance user experience, owners can monitor the last visit of their recipient in the chat room or chat list. However, the core logic for tracking the last visit is not entirely managed by the server. As previously mentioned, the last visit is updated in several parts of the code, with the most critical update occurring in the message list or chat room, where the user's last visit is refreshed in real-time."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="update last seen"',children:"// set last seen\nuseEffect(() => {\n  if (!lastRoom) {\n    return;\n  }\n  // db ref\n  const db = getDatabase();\n  const roomsRef = ref(db, `rooms/${lastRoom.roomId}/${userId}/last_seen`);\n  // set user status online\n  if (selectedRoom) {\n    set(roomsRef, {\n      date: serverTimestamp(),\n    });\n\n    const interval = setInterval(() => {\n      set(roomsRef, {\n        date: serverTimestamp(),\n      });\n    }, 45000); // Adjust interval as needed\n\n    return () => {\n      update(roomsRef, {\n        date: serverTimestamp(),\n        offline: true,\n      });\n      clearInterval(interval);\n    };\n  }\n  // set user status offline\n  return () => {\n    update(roomsRef, {\n      date: serverTimestamp(),\n      offline: true,\n    });\n  };\n}, [lastRoom]);\n"})}),"\n",(0,a.jsx)(t.p,{children:"Moreover, in the recipient's status bar, the logic for determining the last visit of the user is processed in real-time. Even if, for any reason, the last visit is not recorded correctly, the recipient will quickly be alerted when the user goes offline."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="display last seen"',children:'// update last seen\nuseEffect(() => {\n  if (!last_seen) {\n    return;\n  }\n  // ref to current time offset\n  const db = getDatabase();\n  const serverTimeRef = ref(db, ".info/serverTimeOffset");\n  // ref to interval\n  let intervalId;\n  // get server time and update last-seen ref\n  const fetchServerTime = () => {\n    onValue(\n      serverTimeRef,\n      (snapshot) => {\n        // Get the current server time\n        const serverTime = Date.now() + snapshot.val();\n        // Step B-1 & B-2: Calculate the difference between lastSeen.date and serverTime\n        const timeDifference = serverTime - last_seen?.date;\n        const timeDifferenceInSeconds = Math.floor(timeDifference / 1000);\n        // Update the lastStatus based on the difference\n        lastStatus.current =\n          timeDifferenceInSeconds >= 30 || last_seen?.offline\n            ? `last seen at ${calculateLastseen(last_seen?.date)}`\n            : "online";\n      },\n      { onlyOnce: true } // Make sure this reads only once for each fetch\n    );\n  };\n\n  // Start an interval to fetch server time repeatedly\n  fetchServerTime(); // Fetch immediately\n  intervalId = setInterval(fetchServerTime, 15000); // Check every 30 seconds\n\n  // Cleanup interval and Firebase listener on component unmount\n  return () => {\n    clearInterval(intervalId);\n  };\n}, [last_seen]);\n'})}),"\n",(0,a.jsx)(t.h3,{id:"user-info-tab",children:"User Info Tab"}),"\n",(0,a.jsxs)(t.p,{children:["Every chat room allows for the review of user information and their most recent interactions. The nature of these interactions depends on the type of user. If the user type is ",(0,a.jsx)("code",{children:"both"}),", their interactions will be shown both as a customer (including their purchases and product feedback) and as a seller (including their core seller information)."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",metastring:'title="user info parent"',children:'const [infoTab, setInfo] = useState(null);\n\nuseEffect(() => {\n  setInfo(receiver?.userType === "customer" ? "customer" : "seller");\n}, [receiver?.userType]);\n\nreturn (\n  <div>\n    <div\n      className={`${\n        receiver.userType === "both" ? "block" : "hidden"\n      } w-full flex py-2 items-center justify-between`}\n    >\n      <button\n        onClick={() => setInfo("seller")}\n        className={`${\n          infoTab === "seller" && "text-gray-950"\n        } px-4 hover:text-gray-700 rounded-md w-1/2`}\n      >\n        Seller Info\n      </button>\n      <button\n        onClick={() => setInfo("customer")}\n        className={`${\n          infoTab === "customer" && "text-gray-950"\n        } px-4 text-gray-500 lg:hover:text-gray-700 rounded-md w-1/2`}\n      >\n        Customer Info\n      </button>\n    </div>\n    {/* user information */}\n    {infoTab === "customer" ? <CustomerInfo /> : <SellerInfo />}\n  </div>\n);\n'})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1341:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/Draggable-element-test-62ae248166c9ad2df3bcc74d3fbba4be.gif"},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>i});var n=s(6540);const a={},o=n.createContext(a);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);